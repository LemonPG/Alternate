# マイルール

Alternateソリューションにおけるコーディングルールを明確にし、メンテナンス向上やコード分析の向上に役立てることを目的とする。

## ■ファイルの構成について
-----------------------------------------------------------

C++は定義ファイル(ヘッダーファイル)と、実装ファイル(ソースファイル)の２つのファイルで概ね構成されている。実装ファイルではなく、定義ファイル側にプログラムを書くことも可能であるが、当プロジェクトにおいては、定義情報はヘッダーファイルに記載し、プログラムはソースファイルに記載することを大前提とする。

ただし、基本クラスで仮想関数、純粋仮想関数しかない場合や、テンプレート定義されたクラスで関数の実装を利用者にゆだねる場合は、この限りではない。

また、インライン実行を意図してヘッダーファイルにプログラムを実装した場合は、関数の宣言に'inline'の宣言を必ず付ける事。なお、インライン定義は３行以内を目標とする。

## ■ファイル名規約について
-----------------------------------------------------------

ファイル名に関しては、以下をルールとする。

- クラスの宣言、実装を主な用途とする場合は、クラス名をファイル名にする。
- main()関数を含む場合は、プロジェクト名やディレクトリ名をファイル名にする。
- インスタンスの生成が不要な、static関数で構成されたクラスは、○○○○Utilityというように「ユーティリティ」を付加する。
- インスタンスを生成して使用する多目的クラスに関しては、○○○○Helperというように「ヘルパー」を付加する。
- ファイル名は「パスカル記法<sup>(1)</sup>」を主体とし、「スネーク記法<sup>(2)</sup>」は使用しない。

>(1)"TransactionContext"のように、単語単位の先頭が大文字となる記法  
>(2)"transaction_context"のように、単語と単語の間にアンダーバーで連結する記法  
>ちなみにJavaでよく見る"getTransactionContext"のように先頭を小文字にする記法をキャメル記法と呼ぶ。

### ■■クラスの宣言と実装について

クラス名○○○○の宣言、実装を行う場合、ファイルの構成を以下のようにする。

- ヘッダーファイルは、○○○○.hで、拡張子をhxx、hppなどにしない。
- ソースファイルは、○○○○.cppで、拡張子をcxx、c++などにしない。

ただし、ヘッダーファイルだけで宣言と実装が閉じている場合は、拡張子をhppとする。

１つのファイルに、１つのクラスを実装することを推奨する。  
小さいファイルの集合となる場合で、個別にファイルを実装することがかえって煩わしい場合はこの限りではない。

### ■■#includeの構成について

クラス名○○○○において、#includeの構成は以下のようにする。

- CPPファイルのインクルードはできる限り、Hファイルだけにする。
- CPPファイルに定数定義、宣言、マクロ等をできる限り記載しない。左記の要素はできる限り再利用できるようにヘッダーファイル側に記載する。

```C++
// ○○○○.cpp

#include "○○○○.h" // 唯一となる

○○○○::○○○○
{

}
```

```C++
// ○○○○.h

#pragma once

// ここで必要なヘッダーファイルをインクルードする
#include <Windows.h>
#include <stdio.h>

class ○○○○
{
public:
    ○○○○();
    ~○○○○();
};
```

## ■コードの可読性
-----------------------------------------------------------

- 関数は小さく、同じ内容を書かないことを心掛ける。
- １つの実装ファイルに記載可能な行数は**1,000行**以下とする。
- １つの関数に記載可能な行数は**100行**以下とする。
- 変数名は格納する値の内容を先頭に記載する(形容詞となることが多い)。

## ■キャメル記法
-----------------------------------------------------------

キャメル記法は以下の変数に適用する。  
<small>※キャメル記法自体はJavaが発生源であるが、理に適った記法であるため、
当プロジェクトでも採用する。C#と同様のルールである。</small>

1. ローカル変数(キャメル部の名称に困る場合は'my'を推奨する)
1. 関数の引数(キャメル部の名称に困る場合は'prm'を推奨する)
1. クラスのインスタンス変数（先頭にアンダースコアを付ける）

```C++
class SampleValue
{
public:
    SampleValue();
    ~SampleValue();
    bool Validate(int prmValue);

private:
    int _previousValue;
    int _currentValue;
    bool IsValidValue();
};
```

```C++
bool SampleValue::Validate(int prmValue)
{
    int myValue = 0;

    if (prmValue > myValue)
    {
        int temp = _previousValue + prmValue;
    }
}
```

上記以外の変数名、関数名に関してはパスカル記法を使用すること。

## ■リターン文
-----------------------------------------------------------

returnは関数終了間際に**1つ**だけ実装する。

- 複数の出口は想定外の経路を生み、バグの元になる。
- 対策としてはやはり例外構造で書くのが良いかと。

```c++
bool hogehoge (int currentValue, int previousValue)
{
    bool ret; // 関数戻り値設定用

    do
    {
        ret = doSomeFunction(currentValue);
        if (!ret) break;

        ret = doSomeFunction(previousValue);
        if (!ret) break;
    } while (0);

    return ret; // 唯一のreturn
}
```

```C++
bool hogehoge2 (int currentValue, int previousValue)
{
    bool ret == true; // 関数戻り値設定用

    try
    {
        doSomeFunction(currentValue); // エラーの場合は'SomeException'をスロー
        doSomeFunction(previousValue); // エラーの場合は'SomeException'をスロー
    }
    catch (SomeException ex)
    {
        ret = false;
    }
    catch (Exception ex)
    {
        ret = false;
    }
    catch (...)
    {
        ret = false;
    }

    return ret; // 唯一のreturn
}
```
## ■プリプロセッサマクロ
-----------------------------------------------------------
#define などのマクロ定義名は、スネーク記法を使用する。

    #define MAX_PATH 256
    #define MAX_VALUE 512

ただし、プリプロセッサー的要素がない、定数宣言等は*const*を使用した変数宣言を推奨する。こちらの方が、数値に対して型を持ち、型による厳密なリテラルの運用になるためである。

    const int MAX_PATH = 256;
    const int MAX_VALUE = 512;

## ■Doxygenコメント
-----------------------------------------------------------

コメントはDoxygen記法を最優先とする。記載方法については、[こちら](Doxygen.md)を参照すること。

## ■境界判定は可読性を高めること
-----------------------------------------------------------

if のカッコの中に関数を書かない事。デバッグ時に関数の結果を確認しやすくなる。またデバッガによる値の変数で、強制的に分岐テスト等を行うことができる。

```C++
a = funcA();
b = funcB();
if (a >= b)
{
    ...
}
```

## ■引数の数
-----------------------------------------------------------

引数の数が５つ以上になるなら、構造体の導入を検討する。

## ■デザインパターン
-----------------------------------------------------------

Strategyは常に意識する。C++11よりラムダ式が使えるようになったので、これを活用するようにする。

```C++
auto function = [&](int value1, int value2) { return value1 + value2; };
```

```C++
template<typename Function>
int Callback (Function function) { return function(); };
```

```C++
int i = Callback(function(2, 3));
```

インスタンスの複雑な生成が必要な場合、Builderクラスを検討する。

FlyWeightでオブジェクトの再生成を抑制する。大きいオブジェクトはオブジェクトプール構造の検討を。
FlyWeightそのものはSingleton設計になる？

複雑な構造になった場合はFacadeやTemplateMethodを検討する。
TemplateMethodは呼出し方の統一という点では活用すべきだが、その関数そのものまでルール適用ができない。テンプレートメソッドにラムダ式を引数とすることでビジネスロジックまでフレームワークにできると思われる。

生成と処理が複雑になってきたらFactoryMethodやAbstractFactoryを検討する。